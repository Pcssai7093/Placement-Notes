Python is a high level, interpreted, dynamically typed and strongly typed language
python support multiple paradigms of programming

python builtin data types:

1. numeric data types
int
float
bool
complex

2. sequence data types
list
tuple
str
range

3. mapping data types
map

4. set data types
set
frozenset (immutable set)

** pass in python represents a null operations

** implicit type casting happens in python during arithmatic computation of different numberical types
example: 1*1.01 give a float

**
python is operator compares the identity of values or variable
a is b(compares the identity of a with b)


********
In Python, "interning" is an optimization technique used to store and reuse immutable objects (such as small integers, strings, and some other types) to save memory and improve performance. Interning is achieved by storing these objects in a cache so that when you create a new object with the same value, Python can reuse the existing object from the cache rather than creating a new one.

variables with same values point to same memory location at the start of the program to save memory when update they will be assigned different memory location

example:
a=123123123121212
b=123123123121212
print(id(a),id(b))
b+=1
print(id(a),id(b))
print(a,b)


output
-----------
139661619620144 139661619620144
139661619620144 139661619749216
123123123121212 123123123121213

*****
The difference between import and from import in Python is:

import imports an entire code library.
from import imports a specific member or members of the library.

******
from math import sqrt, floor


**
Exception handling in python


try:

except:  (can catch specific exception   ex:  except Exemption_name as e  )

else:

executes if no exception

finally:

execute at end always

as cleanup funtion

-------------------------

** raising and catching custom exceptions

try:
    raise Exception("Sorry, no numbers below zero")
except Exception as e:
    print(e)


*** Exception is type class


-----------------------------------------

** del keyword

delete objects are values in sequence data types

a=[1,2,3,4]
del a[0]
print(a)

output:
[2, 3, 4]


--------------------------------------------------------

** immutable objects are hashable in python
only hashable objects can be put in python states
List are not hashable in python but tuples are hashable


------------------------------------------------------

shallow copying vs deep copying in python

shallow copying : copy the references of the objects

deep copy: create a new object with same value

!! Note: This effect only seen with copy method when arrays have nested arrays or objects

Example::

a=[[1,2],3,4]
b=[*a]
c=a.copy()
print(a,b,c)
a[0][0]=5
print(a,b,c)

Output:
[[1, 2], 3, 4] [[1, 2], 3, 4] [[1, 2], 3, 4]
[[5, 2], 3, 4] [[5, 2], 3, 4] [[5, 2], 3, 4]


Python * operator also do shallow copy
----------------------------------------------------------

Lists in python
-> sequence data type
-> mutable
-> hashable
-> indexed
-> can have different data type objects in same list 

methods
Let x be the list
-> x.insert(index,value)
-> x.append(value)
-> x.extend(other_list)
-> x.copy()
-> x.sort()
-> x.index() (raise exception if value not in list)
-> value in x
-> x.pop(index_to_remove_default_-s)
-> x.clear() // empties list
-> x.count(value) // return the frequency of value
-> x.remove(value) // remove first item with the specified value
-> x=x+x

--------------------------------------------------------------

Tuples in python
-> sequece data type
-> immutable
-> indexed
-> hashable
-> orderd
-> elements in the tuple cannot be modified

methods
let t be the tuple
-> t.count(value)
-> t.index(value)
-> value in t
-> ordered
-> t+t

--------------------------------------------------------------

Sets in Python
-> mutable
-> not hashable
-> not indexed
-> unordered
-> elements can be modified

methods
-> s.add(value)
-> s+s
-> s.remove(value)
-> s.clear()
-> s.copy()
-> s.pop() // remove random element from set
-> s.intersection(set1,set....,etc)
-> s.intersection_update(set1,set....,etc)
-> s.difference(set1,set....,etc)
-> s.difference_update(set1,set....,etc)
-> s.issubset(set2)
-> s.issuperset(set2)
-> s.isdisjoint(set2)
-> s.union(set1,set....,etc)
-> s.update(set1,set....,etc)

